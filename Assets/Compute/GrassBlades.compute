// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

//Input
struct SourceVertex {
    float3 positionOS;
    float3 normalOS;
    float2 uv;
};
StructuredBuffer<SourceVertex> _SourceVertices;
StructuredBuffer<int> _SourceTriangles;

//Output
struct DrawVertex {
    float3 positionWS;
    float2 uv;
};

struct DrawTriangle {
    float3 normalOS;
    DrawVertex vertices[3];
};
//Output vertices
AppendStructuredBuffer<DrawTriangle> _DrawTriangles;

//args
struct IndirectArgs {
    uint numVerticesPerInstance;
    uint numInstances;
    uint startVertexIndex;
    uint startInstanceIndex;
};
RWStructuredBuffer<IndirectArgs> _IndirectArgsBuffer;

float4x4 _LocalToWorld;

int _NumSourceTriangles;
int _SegmentsPerBlade;
int _BladesPerVertex;

float _GrassHeight;
float _GrassWidth;
float _GrassHeightFactor;
float _GrassWidthFactor;

float _BladeForward;
float _BladeCurve;
float _OriginDisplacement;

//Camera LOD
float3 _CameraLOD;
float4 _CameraPos;

#define PI 3.14159265358979323846
#define MAX_GRASS_SEGMENTS 10  // segments per blade allowed
#define GRASS_VERTICES_PER_BLADE (MAX_GRASS_SEGMENTS * 2 + 1)

//https://dvic.devinci.fr/tutorial/Cellular-Automata-with-Shaders
float customRand (float2 st, float seed) {
    return max(0.001, frac(sin(dot(st.xy + seed, float2(12.9898,78.233) * 0.2)) * 43758.5453123));
}
// 2D Noise based on Morgan McGuire @morgan3d
// https://www.shadertoy.com/view/4dS3Wd
float noise (float2 st, float seed) {
    float2 i = floor(st);
    float2 f = frac(st);
    // Four corners in 2D of a tile
    float a = customRand(i, seed);
    float b = customRand(i + float2(1.0, 0.0), seed);
    float c = customRand(i + float2(0.0, 1.0), seed);
    float d = customRand(i + float2(1.0, 1.0), seed);
    // Cubic Hermine Curve.  Same as SmoothStep()
    float2 u = f*f*(3.0-2.0*f);
    // Mix 4 coorners percentages
    return lerp(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
}

//https://en.wikipedia.org/wiki/Rotation_matrix
float3x3 AxisAngleRotation(float angle, float3 axis) {
    float s = sin(angle);
    float c = cos(angle);
    float3x3 rotation = float3x3(
        c + axis.x * axis.x * (1.0f - c), axis.x * axis.y * (1.0f - c) - axis.z * s, axis.x * axis.z * (1.0f - c) + axis.y * s,
        axis.x * axis.y * (1.0f - c) + axis.z * s, c + axis.y * axis.y * (1.0f - c), axis.y * axis.z * (1.0f - c) - axis.x * s,
        axis.x * axis.z * (1.0f - c) + axis.y * s, axis.y * axis.z * (1.0f - c) - axis.x * s, c + axis.z * axis.z * (1.0f - c));
    return rotation;
}

//https://stackoverflow.com/questions/19654251/random-point-inside-triangle-inside-java
float3 GetTrianglePoint(float3 a, float3 b, float3 c, float3 seed) {
    float r1 = sqrt(noise(seed.xz, seed.x));
    float r2 = noise(seed.xz, seed.z);
    float3 pt = (1.0f - r1) * a + (r1 * (1.0f - r2)) * b + (r1 * r2) * c;
    return pt;
}

float3 TransformToWorldSpace(float3 v) {
    return mul(_LocalToWorld, float4(v, 1.0f)).xyz;
}

float3 GetTriangleNormal(float3 a, float3 b, float3 c) {
    return cross(b - a, c - a);
}

float3 GetTriangleCenter(float3 a, float3 b, float3 c) {
    return (a + b + c) / 3.0f;
}

float2 GetBladeSize(float3 seed) {
    float2 size;
    size.x = customRand(seed.xz, seed.x) * _GrassWidthFactor + _GrassWidth;
    size.y = customRand(seed.xz, seed.z) * _GrassHeightFactor + _GrassHeight;
    return size;
}

float2 GetBladeSizeLOD(float3 positionWS, float2 size) {
    float d = distance(positionWS, _CameraPos.xyz);
    d = 1.0f - smoothstep(_CameraLOD.x, _CameraLOD.y, d);
    d = pow(d, _CameraLOD.z);
    return min(size, max(0.0f, d * size));
}

float GetBladeAngle(float3 seed) {
    return customRand(seed.xz, seed.x) * PI * 2.0f;
}

DrawVertex GetGrassVertex(float3 positionOS, float curve, float2 size, float angle, float2 uv) {
    DrawVertex output;
    const float3x3 rotationMatrix = AxisAngleRotation(angle, float3(0, 1, 0));
    float3 newPos = float3(size.x * (uv.x - 0.5), size.y * uv.y, curve);
    
    newPos = positionOS + mul(rotationMatrix, newPos);
    output.positionWS = TransformToWorldSpace(newPos);
    output.uv = uv;
    return output;
}

void AppendTriangle(DrawVertex drawVertices[GRASS_VERTICES_PER_BLADE], int k, float3 faceNormal) {
    DrawTriangle tri = (DrawTriangle)0;
    tri.normalOS = faceNormal;
    tri.vertices[0] = drawVertices[k];
    tri.vertices[1] = drawVertices[k + 1];
    tri.vertices[2] = drawVertices[k + 2];
    _DrawTriangles.Append(tri);
}

int GetSegments(float3 positionWS) {
    float d = distance(positionWS, _CameraPos.xyz);
    d = 1 - smoothstep(_CameraLOD.x, _CameraLOD.y, d);
    d = pow(d, _CameraLOD.z);
    return min(MAX_GRASS_SEGMENTS, max(1, ceil(d * _SegmentsPerBlade)));
}

[numthreads(100,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID) {
    if ((int)id.x >= _NumSourceTriangles) {
        return;
    }
    int triStart = id.x * 3;
    SourceVertex inputs[3];
    inputs[0] = _SourceVertices[_SourceTriangles[triStart]];
    inputs[1] = _SourceVertices[_SourceTriangles[triStart + 1]];
    inputs[2] = _SourceVertices[_SourceTriangles[triStart + 2]];
    
    float3 positionsWS[3];
    positionsWS[0] = TransformToWorldSpace(inputs[0].positionOS);
    positionsWS[1] = TransformToWorldSpace(inputs[1].positionOS);
    positionsWS[2] = TransformToWorldSpace(inputs[2].positionOS);
    
    float3 normal = GetTriangleNormal(positionsWS[0], positionsWS[1], positionsWS[2]);
    int numBladesPerVert = _BladesPerVertex;
    
    int numSegmentsPerBlade = min(MAX_GRASS_SEGMENTS, max(1, _SegmentsPerBlade));
    int numTrianglesPerBlade = (numSegmentsPerBlade - 1) * 2 + 1;
    
    DrawVertex drawVertices[GRASS_VERTICES_PER_BLADE];
    float3 newPos = inputs[0].positionOS;
    
    for (int j = 0; j < numBladesPerVert; ++j)
    {
        float3 seedPos = newPos.xyz / (float)numBladesPerVert * 0.2f;
        newPos = GetTrianglePoint(inputs[0].positionOS, inputs[1].positionOS, inputs[2].positionOS, seedPos);
        float angle = GetBladeAngle(seedPos);
        float2 size = GetBladeSize(seedPos);
        size = GetBladeSizeLOD(TransformToWorldSpace(newPos), size);

        for (int i = 0; i < numSegmentsPerBlade; ++i) {
            float v = i / (float)numSegmentsPerBlade;
            float u = v * 0.5f;

            if (v == 0) { u += _OriginDisplacement; }
            float segmentForward = pow(abs(v), _BladeCurve) * _BladeForward;
     
            drawVertices[i * 2] = GetGrassVertex(newPos, segmentForward, size, angle, float2(u, v));
            drawVertices[i * 2 + 1] = GetGrassVertex(newPos, segmentForward, size, angle, float2(1 - u, v));
        }
        drawVertices[numSegmentsPerBlade * 2] = GetGrassVertex(newPos, _BladeForward, size, angle, float2(0.5, 1));
        
        for (int k = 0; k < numTrianglesPerBlade; ++k) {
            AppendTriangle(drawVertices, k, normal);
        }
    }
    
    // counts the number of vertices, storing it in the indirect arguments
    // This tells the renderer how many vertices are in the mesh in DrawProcedural
    InterlockedAdd(_IndirectArgsBuffer[0].numVerticesPerInstance, numTrianglesPerBlade * 3 * numBladesPerVert);
}



