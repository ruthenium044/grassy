// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

//Input
struct SourceVertex {
    float3 positionOS;
    float3 normalOS;
    float2 uv;
};
StructuredBuffer<SourceVertex> _SourceVertices;
StructuredBuffer<int> _SourceTriangles;

//Output
struct DrawVertex {
    float3 positionWS;
    float2 uv;
};

struct DrawTriangle {
    float3 normalOS;
    DrawVertex vertices[3];
};
//Output vertices
AppendStructuredBuffer<DrawTriangle> _DrawTriangles;

//args
struct IndirectArgs {
    uint numVerticesPerInstance;
    uint numInstances;
    uint startVertexIndex;
    uint startInstanceIndex;
};
RWStructuredBuffer<IndirectArgs> _IndirectArgsBuffer;

float4x4 _LocalToWorld;

int _NumSourceTriangles;
int _SegmentsPerBlade;
int _BladesPerVertex;

float _GrassHeight;
float _GrassWidth;
float _GrassHeightFactor;
float _GrassWidthFactor;

float _BladeForward;
float _BladeCurve;
float _OriginDisplacement;

#define PI 3.14159265358979323846
#define MAX_GRASS_SEGMENTS 10  // segments per blade allowed
#define GRASS_VERTICES_PER_BLADE (MAX_GRASS_SEGMENTS * 2 + 1)

// 2D Noise based on Morgan McGuire @morgan3d
// https://www.shadertoy.com/view/4dS3Wd
float random(float p) {
    p = frac(p * 0.011);
    p *= p + 7.5;
    p *= p + p;
    return frac(p);
}

float random (float2 st, float seed) {
    return frac(sin(dot(st.xy + seed, float2(12.9898,78.233))) * 43758.5453123);
}

float noise(float x) {
    float i = floor(x);
    float f = frac(x);
    float u = f * f * (3.0 - 2.0 * f);
    return lerp(random(i), random(i + 1.0), u);
}

float noise (float2 st, float seed) {
    float2 i = floor(st);
    float2 f = frac(st);
    // Four corners in 2D of a tile
    float a = random(i, seed);
    float b = random(i + float2(1.0, 0.0), seed);
    float c = random(i + float2(0.0, 1.0), seed);
    float d = random(i + float2(1.0, 1.0), seed);
    // Cubic Hermine Curve.  Same as SmoothStep()
    float2 u = f*f*(3.0-2.0*f);
    // Mix 4 coorners percentages
    return lerp(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
}

float3x3 AxisAngleRotation(float angle, float3 axis) {
    float s = sin(angle);
    float c = cos(angle);
    float3x3 rotation = float3x3(
        c + axis.x * axis.x * (1 - c), axis.x * axis.y * (1 - c) - axis.z * s, axis.x * axis.z * (1 - c) + axis.y * s,
        axis.x * axis.y * (1 - c) + axis.z * s, c + axis.y * axis.y * (1 - c), axis.y * axis.z * (1 - c) - axis.x * s,
        axis.x * axis.z * (1 - c) + axis.y * s, axis.y * axis.z * (1 - c) - axis.x * s, c + axis.z * axis.z * (1 - c));
    return rotation;
}

float3 TransformToWorldSpace(float3 v) {
    return mul(_LocalToWorld, float4(v, 1)).xyz;
}

float3 GetTrianglePoint(float3 a, float3 b, float3 c, float seed) {
    float r1 = noise(a.x * 10 + a.z + seed);
    float r2 = noise(c.x * 10 + c.z + seed);
    float3 pt = (1 - sqrt(r1)) * a + (sqrt(r1) * (1 - r2)) * b + (sqrt(r1) * r2) * c;
    return pt;
}

float3 GetTriangleNormal(float3 a, float3 b, float3 c) {

    //float3 perpendicularAngle = float3(0, 0, 1);
    //float3 faceNormal = cross(perpendicularAngle, sv.normalOS); 
    return float3(0, 1, 0);
}

float2 GetBladeSize(float3 pos, float seed) {
    float2 size;
    size.x = noise(pos.xz, seed) * _GrassWidthFactor + _GrassWidth;
    size.y = noise(pos.xz, seed) * _GrassHeightFactor + _GrassHeight;
    return size;
}

float GetBladeAngle(float3 pos, float seed) {
    return noise(pos.xz, seed) * PI * 2.0f;
}

DrawVertex GetGrassVertex(float3 positionOS, float curve, float2 size, float angle, float2 uv) {
    DrawVertex output;
    const float3x3 rotationMatrix = AxisAngleRotation(angle, float3(0, 1, 0));
    float3 newPos = float3(size.x * (uv.x - 0.5), size.y * uv.y, curve);
    
    newPos = positionOS + mul(rotationMatrix, newPos);
    output.positionWS = mul(_LocalToWorld, float4(newPos, 1)).xyz;
    output.uv = uv;
    return output;
}

void AppendTriangle(DrawVertex drawVertices[GRASS_VERTICES_PER_BLADE], int k, float3 faceNormal) {
    DrawTriangle tri = (DrawTriangle)0;
    tri.normalOS = faceNormal;
    tri.vertices[0] = drawVertices[k];
    tri.vertices[1] = drawVertices[k + 1];
    tri.vertices[2] = drawVertices[k + 2];
    _DrawTriangles.Append(tri);
}

[numthreads(100,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID) {
    if ((int)id.x >= _NumSourceTriangles) {
        return;
    }
    int triStart = id.x * 3;
    SourceVertex inputs[3];
    inputs[0] = _SourceVertices[_SourceTriangles[triStart]];
    inputs[1] = _SourceVertices[_SourceTriangles[triStart + 1]];
    inputs[2] = _SourceVertices[_SourceTriangles[triStart + 2]];
    
    float3 positionsWS[3];
    positionsWS[0] = TransformToWorldSpace(inputs[0].positionOS);
    positionsWS[1] = TransformToWorldSpace(inputs[1].positionOS);
    positionsWS[2] = TransformToWorldSpace(inputs[2].positionOS);
    
    float3 normal = GetTriangleNormal(positionsWS[0], positionsWS[1], positionsWS[2]);
    
    int numSegmentsPerBlade = min(MAX_GRASS_SEGMENTS, max(1, _SegmentsPerBlade));
    int numBladesPerVert = _BladesPerVertex;
    int numTrianglesPerBlade = (numSegmentsPerBlade - 1) * 2 + 1;
    
    DrawVertex drawVertices[GRASS_VERTICES_PER_BLADE];
    for (int j = 0; j < numBladesPerVert; ++j)
    {
        //float3 newPos = GetTrianglePoint(positionsWS[0], positionsWS[1], positionsWS[2], j);
        float3 newPos = GetTrianglePoint(inputs[0].positionOS, inputs[1].positionOS, inputs[2].positionOS, j);
        float2 size = GetBladeSize(inputs[0].positionOS, j);
        float angle = GetBladeAngle(inputs[0].positionOS, j);

        for (int i = 0; i < numSegmentsPerBlade; ++i) {
            float v = i / (float)numSegmentsPerBlade;
            float u = v * 0.5f;

            if (v == 0) { u += _OriginDisplacement; }
            float segmentForward = pow(abs(v), _BladeCurve) * _BladeForward;
     
            drawVertices[i * 2] = GetGrassVertex(newPos, segmentForward, size, angle, float2(u, v));
            drawVertices[i * 2 + 1] = GetGrassVertex(newPos, segmentForward, size, angle, float2(1 - u, v));
        }
        drawVertices[numSegmentsPerBlade * 2] = GetGrassVertex(newPos, _BladeForward, size, angle, float2(0.5, 1));
        
        for (int k = 0; k < numTrianglesPerBlade; ++k) {
            AppendTriangle(drawVertices, k, normal);
        }
    }
    
    // counts the number of vertices, storing it in the indirect arguments
    // This tells the renderer how many vertices are in the mesh in DrawProcedural
    InterlockedAdd(_IndirectArgsBuffer[0].numVerticesPerInstance, numTrianglesPerBlade * 3 * numBladesPerVert);
}



